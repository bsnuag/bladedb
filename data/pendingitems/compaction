We will go with LCS + Size teired -

1. 3 level (1st level is flush of memtable, can have intervals) (level-2 & 3 cannot have intervals)
2. 2nd level will have no overlaps (each table 32 mb)
3. compaction should get trigger when there are at least 4 files
(just a random number, very less num will have less duplicate and compaction will result any benefit) in 0th level
4. from level 0 to level 1 must be merge of this 4
5. from level 1 onwards we must use merge with next level
6.


- have a queue which listens on action from compaction - when compaction is in progress and one SST file's ends gets




16MB-64MB(10 table)-64MB(all tables)





Must - updated on 30th Jan

[DONE]1. each file of level 0 might not have overlaps with level 1 files, but combining them may have - how many file from level 0 to take ? below is an exampe
//https://github.com/apache/cassandra/blob/8a3f0e11fecde964730cd67d6376660ae562b208/src/java/org/apache/cassandra/db/compaction/LeveledManifest.java#L248
//	*   candidates = [ s1(a, c), s2(m, z) ]
//	*   others = [ s3(e, g) ]

[DONE]2. check if number of levels must be just 2. - Cannot be just 2, else overlaps from level 0 to 1 can be entire data of db

[DONE]3. on 1st point - if there is no overlap from level 0 to level 1 and if number of files is greater than n (to be decided) then run compaction else ignore
[DONE]4. remove level number from sst files
[DONE]5. add manifesto file to keep levels information -
6. compaction from level 1 onwards..yet to do
7. have 2 byte buffer (read/write) per partition instead of creating buffer each time  - GC timer saver
8. leveled compaction video by cassandra - really helpful
..https://github.com/facebook/rocksdb/wiki/Choose-Level-Compaction-Files
9. fillTopLevels() -

